### **Problem link**

---

https://www.geeksforgeeks.org/problems/reverse-an-array/1

### **Intuition**

---

we can solve this problem using two approaches:

- In first approach we create an empty `ans` array and then we traverse on input array in reverse order and one by one push the element in our answer array.
- In second approach we use two pointer approach and swap the left element by right element.

### **Approach 1**

---
Using extra array:   

Let's take an example:

```
Input : arr = [1,2,3,4]
```

the output should be :

```
[4,3,2,1]
```

### **Why this works?**

---

We initialize an empty array `ans` that will store the result.

Initially:

```
ans = []
```

then we traverse on the input array reversely and update the `ans` array

### **Step-by-step Dry Run**

---

On every iteration we push the element on our answer array.

```
Iteration 1. [1, 2, 3, 4]    ans = [4]
                       ↑
                       i = 3
```

```
Iteration 2. [1, 2, 3, 4]    ans = [4, 3]
                    ↑
                    i = 2
```

```
Iteration 3. [1, 2, 3, 4]    ans = [4, 3, 2]
                 ↑
                 i = 1
```

```
Iteration 4. [1, 2, 3, 4]    ans = [4, 3, 2, 1]
              ↑
              i = 0
```

Now we reach the end of the input array so we here return our `ans` array

```
return [4, 3, 2, 1]
```

### **Complexity**

---

- Time complexity:  
  we are traversing on the whole array at once so the time complexity is _O(n)_
- Space Complexity:  
  we are using extra space `ans` so the space complexity is _O(n)_

### **JavaScript Code**

```javascript []
function getMinMax(arr) {
  const ans = [];

  for (let i = arr.length - 1; i >= 0; i--) {
    ans.push(arr[i]);
  }

  return ans;
}
```

### **Approach 2**

---
Two-pointer (In-place)  
  
let's take the same example :

```
Input : arr = [1,2,3,4]
```

it's output should be :

```
[4,3,2,1]
```

### **Why this works?**

---

we maintain two pointers, `left` and `right`

`left`  → start at index 0  
`right` → start at index n - 1

Initially :
```
left = 0
right = n - 1 
        ↑
        length of array 
```
At each step, we swap the values at left and right, then move the pointers closer.


### **Step-by-step Dry Run**

---

Let's go through each step :
```
Iteration 1.

0   <   3    → true
↑       ↑
left    right


[1, 2, 3, 4]     →     [4, 2, 3, 1]
 ↑        ↑    swap     ↑        ↑

```
```
Iteration 2.

1   <   2    → true
↑       ↑
left    right


[1, 2, 3, 4]     →   [4, 3, 2, 1]
    ↑  ↑       swap      ↑  ↑

```
```
Iteration 3.

2   <   1    → false
↑       ↑
left    right


Loop end...

```
Now the array is reversed.

### **Complexity**

---

- Time complexity:
we are traversing on input array at once so the time complexity is _O(n)_
- Space Complexity: 
we are not using any extra space except `left` and `right` variable so space complexity is *O(1)*
### **JavaScript Code**

```javascript []
function getMinMax(arr) {
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    let temp = arr[left];
    arr[left] = arr[right];
    arr[right] = temp;
    left++;
    right--;
  }
}
```
