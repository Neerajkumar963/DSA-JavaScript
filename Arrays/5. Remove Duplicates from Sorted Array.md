### **Problem Link**

---


https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/   

### **Intuition**

---
If we can place each unique element at the front of the array (in sorted order as they appear), then the index where we stop inserting represents the count of unique elements.
### **Approach 1**

Using Hash Set - Works for Unsorted Also - O(n) Time and O(n) Space
- Create a HashSet to keep track of elements we have already seen.

- Maintain an index idx = 0 to store the next unique element.

- Traverse the array:

- If element is not in the HashSet, insert it at nums[idx], increase idx, and add it to the set.

- After the loop ends, idx tells how many unique elements are placed at the front.

- Return idx.
### **Why This Works?**

---
A HashSet guarantees that each element is checked for uniqueness in O(1) time.
So every time we find a number that is not in the set, we know it has not appeared earlier.
Thus, placing it at idx builds the array of unique values without duplicates.

Since all duplicates will be skipped, the index idx automatically becomes the count of unique elements.

Let’s use the input:  
```
nums = [1, 2, 2, 3, 1, 4]
```
### **Step-by-step Dry Run**

---
Initial State:  
```
nums = [1, 2, 2, 3, 1, 4]
set  = { }
idx  = 0

```
```
        idx = 0
        ↓
nums = [1, 2, 2, 3, 1, 4]                 
        ↑
        i = 0

set  = { }        
nums[i] = 1 not in set → unique 
place nums[idx] = nums[i]

nums = [1, 2, 2, 3, 1, 4]

set = {1} Added to set
idx++  idx increment

```
```
           idx = 1
           ↓
nums = [1, 2, 2, 3, 1, 4]                 
           ↑
           i = 1

set  = {1}        
nums[i] = 2 not in set → unique 
place nums[idx] = nums[i]

nums = [1, 2, 2, 3, 1, 4]

set = {1, 2} Added to set
idx++  idx increment

```
```
              idx = 2
              ↓
nums = [1, 2, 2, 3, 1, 4]                 
              ↑
              i = 2

set  = {1, 2}        
nums[i] = 2 is present in set → duplicate 

Skip (do nothing)

```
```
              idx = 2
              ↓
nums = [1, 2, 2, 3, 1, 4]                 
                 ↑
                 i = 3

set  = {1, 2}        
nums[i] = 3 not in set → unique 
place nums[idx] = nums[i]

nums = [1, 2, 3, 3, 1, 4]

set = {1, 2, 3} Added to set
idx++  idx increment

```
```
                 idx = 3
                 ↓
nums = [1, 2, 3, 3, 1, 4]                 
                    ↑
                    i = 4

set  = {1, 2, 3}        
nums[i] = 1 is present in set → duplicate 

Skip (do nothing)

```
```
                 idx = 3
                 ↓
nums = [1, 2, 3, 3, 1, 4]                 
                       ↑
                       i = 5

set  = {1, 2, 3}        
nums[i] = 4 not in set → unique 
place nums[idx] = nums[i]

nums = [1, 2, 3, 4, 1, 4]

set = {1, 2, 3, 4} Added to set
idx++  idx increment

```
Unique elements stored in first idx positionn
→ [1, 2, 3, 4]

Returned value = idx = 4
### **Time & Space Complexity**

---
### **Time Complexity :-**
O(n)

Reason:

- You traverse the array once → O(n)
- Each HashSet operation (add/check) is O(1) on average
- Writing unique elements into the array is also O(1) each
- So total time = n × O(1) = O(n)   

### **Space Complexity :-** 
O(n) (in worst case)

Reason:

- HashSet may store all elements if all are unique
- Thus extra space grows with the number of unique elements → up to n
- Array rewriting is in-place, but HashSet makes it not O(1) space.

### **JavaScript Code**

```js
function removeDuplicates(nums) {
  const set = new Set();
  let idx = 0;

  for (let i = 0; i < nums.length; i++) {
    if (!set.has(nums[i])) {
      set.add(nums[i]);
      nums[idx] = nums[i];
      idx++;
    }
  }

  return idx; // number of unique elements
}


```
