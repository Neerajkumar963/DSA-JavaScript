### **Problem Link**

---


https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/   

### **Intuition**

---
If we can place each unique element at the front of the array (in sorted order as they appear), then the index where we stop inserting represents the count of unique elements.
### **Approach 1**

Using Hash Set - Works for Unsorted Also - O(n) Time and O(n) Space
- Create a HashSet to keep track of elements we have already seen.

- Maintain an index idx = 0 to store the next unique element.

- Traverse the array:

- If element is not in the HashSet, insert it at nums[idx], increase idx, and add it to the set.

- After the loop ends, idx tells how many unique elements are placed at the front.

- Return idx.
### **Why This Works?**

---
A HashSet guarantees that each element is checked for uniqueness in O(1) time.
So every time we find a number that is not in the set, we know it has not appeared earlier.
Thus, placing it at idx builds the array of unique values without duplicates.

Since all duplicates will be skipped, the index idx automatically becomes the count of unique elements.

Let’s use the input:  
```
nums = [1, 2, 2, 3, 1, 4]
```
### **Step-by-step Dry Run**

---
Initial State:  
```
nums = [1, 2, 2, 3, 1, 4]
set  = { }
idx  = 0

```
```
        idx = 0
        ↓
nums = [1, 2, 2, 3, 1, 4]                 
        ↑
        i = 0

set  = { }        
nums[i] = 1 not in set → unique 
place nums[idx] = nums[i]

nums = [1, 2, 2, 3, 1, 4]

set = {1} Added to set
idx++  idx increment

```
```
           idx = 1
           ↓
nums = [1, 2, 2, 3, 1, 4]                 
           ↑
           i = 1

set  = {1}        
nums[i] = 2 not in set → unique 
place nums[idx] = nums[i]

nums = [1, 2, 2, 3, 1, 4]

set = {1, 2} Added to set
idx++  idx increment

```
```
              idx = 2
              ↓
nums = [1, 2, 2, 3, 1, 4]                 
              ↑
              i = 2

set  = {1, 2}        
nums[i] = 2 is present in set → duplicate 

Skip (do nothing)

```
```
              idx = 2
              ↓
nums = [1, 2, 2, 3, 1, 4]                 
                 ↑
                 i = 3

set  = {1, 2}        
nums[i] = 3 not in set → unique 
place nums[idx] = nums[i]

nums = [1, 2, 3, 3, 1, 4]

set = {1, 2, 3} Added to set
idx++  idx increment

```
```
                 idx = 3
                 ↓
nums = [1, 2, 3, 3, 1, 4]                 
                    ↑
                    i = 4

set  = {1, 2, 3}        
nums[i] = 1 is present in set → duplicate 

Skip (do nothing)

```
```
                 idx = 3
                 ↓
nums = [1, 2, 3, 3, 1, 4]                 
                       ↑
                       i = 5

set  = {1, 2, 3}        
nums[i] = 4 not in set → unique 
place nums[idx] = nums[i]

nums = [1, 2, 3, 4, 1, 4]

set = {1, 2, 3, 4} Added to set
idx++  idx increment

```
Unique elements stored in first idx positionn
→ [1, 2, 3, 4]

Returned value = idx = 4
### **Time & Space Complexity**

---
### **Time Complexity :-**
O(n)

Reason:

- You traverse the array once → O(n)
- Each HashSet operation (add/check) is O(1) on average
- Writing unique elements into the array is also O(1) each
- So total time = n × O(1) = O(n)   

### **Space Complexity :-** 
O(n) (in worst case)

Reason:

- HashSet may store all elements if all are unique
- Thus extra space grows with the number of unique elements → up to n
- Array rewriting is in-place, but HashSet makes it not O(1) space.

### **JavaScript Code**

```js
function removeDuplicates(nums) {
  const set = new Set();
  let idx = 0;

  for (let i = 0; i < nums.length; i++) {
    if (!set.has(nums[i])) {
      set.add(nums[i]);
      nums[idx] = nums[i];
      idx++;
    }
  }

  return idx; // number of unique elements
}


```
### **Approach 2 (Two Pointers, O(1) Space)**

1. Since the array is sorted, duplicates will always appear next to each other.
2. Maintain two pointers:
   - `write` → points to the position where we will place the next unique element.
   - `read` → scans the array from left to right.
3. Start with `write = 0`.  
   Then loop `read` from index `1` to the end of the array.
4. For each step:
   - Compare the value at `nums[read]` with `nums[write]`.
   - If the values differ, it means we found a **new unique element**.
     - Move `write` one step forward.
     - Copy this new unique value to `nums[write]`.
   - If they are the same, it’s a duplicate → skip it.
5. After the loop finishes, all unique elements will be placed in `nums[0 to write]`.
6. The count of unique elements = `write + 1`.

### **Why This Works**

- The array is sorted, ensuring all duplicates appear consecutively.
- The `read` pointer finds the next element that is different from the last unique element at `nums[write]`.
- When a new unique element is found, placing it at `write + 1` compacts all unique values at the front of the array while preserving their original order.
- Since each unique value is written exactly once into `nums[0..write]`, no duplicates are included in this prefix.
- Only the two pointers (`read` and `write`) are used, so the extra space needed is **O(1)**.
- Each element is processed exactly once, giving a time complexity of **O(n)**.

### Step-by-step Dry Run (Two Pointers)
```
Input (sorted):
1 1 2 2 2 3 4 4

Initial pointers:
write = 0    (points at first element)
read  = 1    (starts scanning from second element)
```
```
Iteration 1.

arr: 1 1 2 2 2 3 4 4
     w r

arr[w] === arr[r] --> true so skip

```
```
Iteration 2.

arr: 1 1 2 2 2 3 4 4
     w   r

arr[w] === arr[r] --> false do w++
then,
arr[w] = arr[r]
arr become,
arr: 1 2 2 2 2 3 4 4
       w r
```
```
Iteration 3.

arr: 1 2 2 2 2 3 4 4
       w   r

arr[w] === arr[r] --> true so skip

```
```
Iteration 4.

arr: 1 2 2 2 2 3 4 4
       w     r

arr[w] === arr[r] --> true so skip

```
```
Iteration 5.

arr: 1 2 2 2 2 3 4 4
       w       r

arr[w] === arr[r] --> false do w++
then,
arr[w] = arr[r]
arr become,
arr: 1 2 3 2 2 3 4 4
         w     r

```
```
Iteration 6.

arr: 1 2 3 2 2 3 4 4
         w       r

arr[w] === arr[r] --> false do w++
then,
arr[w] = arr[r]
arr become,
arr: 1 2 3 4 2 3 4 4
           w     r

```
```
Iteration 7.

arr: 1 2 3 4 2 3 4 4
           w       r

arr[w] === arr[r] --> true so skip

```
Final result

Unique values are in nums[0..write] → [1, 2, 3, 4]

Count of unique elements = write + 1 = 4

Return 4.

### **Time Complexity**
**O(n)**

- The `read` pointer scans the array exactly once.
- Each element is compared and possibly written at most one time.
- No nested loops or repeated work.

Total operations grow linearly with the array size → **O(n)**.

---

### **Space Complexity**
**O(1)**

- We use only two integer pointers: `write` and `read`.
- No extra data structures (no hashset, no map, no extra array).
- Array is modified in-place.

Therefore, additional space remains constant → **O(1)**.

```js
function removeDuplicates(nums) {
  if (nums.length === 0) return 0;

  let write = 0;

  for (let read = 1; read < nums.length; read++) {
    if (nums[read] !== nums[write]) {
      write++;
      nums[write] = nums[read];
    }
  }

  return write + 1; // number of unique elements
}
```


